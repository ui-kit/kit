:doc
  @name UIFlyout
  recommended skins:
    %ui-kit/skins/flyout/index.ess
    %ui-kit/skins/flyout/position/bottom.ess
  @prop {Boolean}  [hideOnClick] Always hide flyout after anything is clicked
  @prop {String}   [position] applies state classes for position
  @prop {Boolean}  [showCloseButton=false] Shows close button that calls hideMenu
  @prop {Boolean}  [lazyYield] Do not yield the menu unless menu is active
  @prop {Boolean}  [manualHide] Only hide flyout by calling toggle or hide
  @prop {Boolean}  [showMenuOnLoad] Mounts with flyout open
  @prop {Number}   [animationTimeout=0] number in ms to wait before removing menu, or sending false value for isActive
  @prop {Boolean}  [scrollToMenu=true] body will scroll to fully show menu when active
  @prop {Object}   [scrollToMenuOptions={}] custom options for scroll-to-element
  @prop {String}   [hideMenuKeyBinding] key to listen for that will hide flyout
  @prop {String}   [showMenuKeyBinding] key to listen for that will show flyout
  @prop {String}   [toggleMenuKeyBinding] key to listen for that will toggle flyout
  @prop {Function} [onShow] called after flyout shows
  @prop {Function} [onHide] called after flyout hides
  @prop {Function} [onWindowClickHide] this is called when flyout will hide because of clicking outside the menu (onHide will also be called)
  @prop {Function} [onComponentWillHide] called when component will hide
  @prop {Funciton} [onComponentWillShow] called when component will show
  @prop {Function} [onKeybindingPress] called when a keybinding is pressed
    @arg {String} action - the keybinding action called (show, hide, toggle)

import * as scrollToElement from 'scroll-to-element'
import elContains from '../../utils/element-contains-el'
import {attachKeybinding, removeKeybindings, hasKeybinding} from '../../utils/keybinding.js'

:js
  var classFn = this.composeClasses('UIFlyout', {
    'active': state.isActive,
    'has-trigger': !!props.trigger
  })

  var fns= {
    classFn: classFn,
    hide: this.startHidingMenu,
    show: this.startShowingMenu,
    toggle: this.toggleMenu }

  var menuStates = {
    'showing': state.isActive,
    'animating-show': state.showMenuStarted,
    'animating-hide': state.hideMenuStarted,
    'position-@': props.position
  }

div(className=classFn())
  yield trigger(fns, state.isActive)
  if props.lazyYield
    if state.isActive || state.showMenuStarted || state.hideMenuStarted
      div(className=classFn('&-menu', menuStates) ref='menu')
        yield menu(fns, state.isActive)
        if props.showCloseButton
          div(className=classFn('&-menu-close') onClick=this.startHidingMenu)
  else
    div(className=classFn('&-menu', menuStates) ref='menu')
      yield menu(fns, state.isActive)
      if props.showCloseButton
        div(className=classFn('&-menu-close') onClick=this.startHidingMenu)

:module
  export var mixins = [require('../../mixins/compose-classes')]

  export function getDefaultProps () {
    return {
      position: 'bottom-middle',
      animationTimeout: 0,
      scrollToMenu: {}
    };
  }

  export function componentDidMount () {
    if (this.props.showMenuKeyBinding) {
      attachKeybinding(this.props.showMenuKeyBinding, this.onKeybindingPress.bind(null, 'show'));
    }
    if (this.props.toggleMenuKeyBinding) {
      attachKeybinding(this.props.toggleMenuKeyBinding, this.onKeybindingPress.bind(null, 'toggle'));
    }
    if (this.props.showMenuOnLoad) this.startShowingMenu();
  }

  export function componentWillReceiveProps (nextProps) {
    if (nextProps.showMenuKeyBinding !== this.props.showMenuKeyBinding && hasKeybinding(this.props.showMenuKeyBinding)) {
      removeKeybindings(this.props.showMenuKeyBinding);
      attachKeybinding(nextProps.showMenuKeyBinding, this.onKeybindingPress.bind(null, 'show'));
    }
    if (nextProps.hideMenuKeyBinding !== this.props.hideMenuKeyBinding && hasKeybinding(this.props.hideMenuKeyBinding)) {
      removeKeybindings(this.props.hideMenuKeyBinding);
      attachKeybinding(nextProps.hideMenuKeyBinding, this.onKeybindingPress.bind(null, 'hide'));
    }
    if (nextProps.toggleMenuKeyBinding !== this.props.toggleMenuKeyBinding && hasKeybinding(this.props.toggleMenuKeyBinding)) {
      removeKeybindings(this.props.toggleMenuKeyBinding);
      attachKeybinding(nextProps.toggleMenuKeyBinding, this.onKeybindingPress.bind(null, 'toggle'));
    }
    if (nextProps.showMenuOnLoad && !this.state.hasShownMenu) {
      this.startShowingMenu();
    }
  }

  export function componentDidUpdate (prevProps, prevState) {
    if (this.state.isActive && !prevState.isActive) {
      this.scrollToMenu();
      if (this.props.onShow) this.props.onShow();
      if (!this.props.manualHide) window.addEventListener('click', this.onWindowClick);
    }

    if (!this.state.isActive && prevState.isActive) {
      if (this.props.onHide) this.props.onHide();
    }

    if (this.state.hideMenuStarted && !prevState.hideMenuStarted) {
      setTimeout(this.hideMenu, this.props.animationTimeout);
    }

    if (this.state.showMenuStarted && !prevState.showMenuStarted) {
      setTimeout(this.showMenu, 0);
    }
  }

  export function componentWillUnmount () {
    window.removeEventListener('click', this.onWindowClick);
    removeKeybindings([this.props.showMenuKeyBinding, this.props.hideMenuKeyBinding, this.props.toggleMenuKeyBinding]);
    if (this.state.isActive && this.props.onHide) this.props.onHide();
  }

  export function onKeybindingPress (action) {
    if (this.props.onKeybindingPress) this.props.onKeybindingPress(action);
    switch (action) {
      case 'toggle':
        this.toggleMenu();
        break;
      case 'show':
        this.startShowingMenu();
        break;
      case 'hide':
        this.startHidingMenu();
        break;
    }
  }

  export function toggleMenu (evt) {
    this.state.isActive ?
      this.startHidingMenu(evt) :
      this.startShowingMenu(evt);
  }

  export function startShowingMenu (evt) {
    if (this.state.isActive) return;
    if (this.props.onComponentWillShow) this.props.onComponentWillShow();
    if (this.props.showMenuKeyBinding) removeKeybindings(this.props.showMenuKeyBinding);
    if (this.props.hideMenuKeyBinding) attachKeybinding(this.props.hideMenuKeyBinding, this.onKeybindingPress.bind(null, 'hide'));
    this.setState({showMenuStarted: true, hasShownMenu: true});
  }

  export function startHidingMenu (evt) {
    if (!this.state.isActive) return;
    if (evt) evt.stopPropagation();
    if (this.props.onComponentWillHide) this.props.onComponentWillHide();
    if (this.props.hideMenuKeyBinding) removeKeybindings(this.props.hideMenuKeyBinding);
    if (this.props.showMenuKeyBinding) attachKeybinding(this.props.showMenuKeyBinding, this.onKeybindingPress.bind(null, 'show'));
    this.setState({hideMenuStarted: true});
    window.removeEventListener('click', this.onWindowClick);
  }

  export function hideMenu () {
    this.setState({hideMenuStarted: false, isActive: false});
  }

  export function showMenu () {
    this.setState({showMenuStarted: false, isActive: true});
  }

  export function scrollToMenu () {
    var menu = this.refs.menu && this.refs.menu.getDOMNode();
    if (!menu || !this.props.scrollToMenu) return;

    var defaultOptions = {
      align: 'bottom',
      ease: 'inOutSine',
      duration: 150,
      offset: 12
    };

    var scrollToMenuOptions = Object.assign(defaultOptions, this.props.scrollToMenuOptions);

    if (menu.getBoundingClientRect().bottom > window.innerHeight && scrollToElement) {
      scrollToElement(menu, scrollToMenuOptions);
    }
  }

  export function onWindowClick (evt) {
    if (!this.isMounted()) return;
    var el = this.getDOMNode();
    if (this.props.hideOnClick || !elContains(el, evt.target)) {
      if (this.props.onWindowClickHide && !elContains(el, evt.target)) this.props.onWindowClickHide();
      this.startHidingMenu();
    }
  }